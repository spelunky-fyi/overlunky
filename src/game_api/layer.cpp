#include "layer.hpp"

#include <cmath>   // for round, roundf
#include <cstdint> // for uint32_t, uint8_t
#include <cstdlib> // for abs
#include <tuple>   // for tie, tuple

#include "entities_floors.hpp" // for ExitDoor
#include "entity.hpp"          // for Entity, to_id, EntityDB, entity_factory
#include "logger.h"            // for DEBUG
#include "movable.hpp"         // for Movable
#include "rpc.hpp"             //
#include "search.hpp"          // for get_address
#include "state.hpp"           // for State, StateMemory

struct EntityFactory;

Entity* Layer::spawn_entity(ENT_TYPE id, float x, float y, bool screen, float vx, float vy, bool snap)
{
    if (id == 0)
        return nullptr;

    using LoadItem = Entity*(Layer*, ENT_TYPE, float, float, bool);
    static auto load_item = (LoadItem*)get_address("load_item");

    float min_speed_check = 0.01f;
    if (!screen && snap)
    {
        x = round(x);
        y = round(y);
    }
    else if (screen)
    {
        std::tie(x, y) = StateMemory::click_position(x, y);
        min_speed_check = 0.04f;
        if (snap && abs(vx) + abs(vy) <= min_speed_check)
        {
            x = round(x);
            y = round(y);
        }
    }

    Entity* spawned = load_item(this, id, x, y, false);
    if (abs(vx) + abs(vy) > min_speed_check && spawned->is_movable())
    {
        auto movable = (Movable*)spawned;
        movable->velocityx = vx;
        movable->velocityy = vy;
    }

    // DEBUG("Spawned {}", fmt::ptr(spawned));
    return spawned;
}

void snap_to_floor(Entity* ent, float y)
{
    ent->y = y + ent->hitboxy - ent->offsety;
    Entity* overlay = ent->overlay;
    while (overlay != nullptr)
    {
        ent->y -= overlay->y;
        overlay = overlay->overlay;
    }
}

Entity* Layer::spawn_entity_snap_to_floor(ENT_TYPE id, float x, float y)
{
    const EntityDB* type = get_type(id);
    const float y_center = roundf(y) - 0.5f;
    const float snapped_y = y_center + type->default_collision_info.rect.hitboxy - type->default_collision_info.rect.offsety;
    Entity* ent = spawn_entity(id, x, snapped_y, false, 0.0f, 0.0f, false);
    if ((type->search_flags & 0x700) == 0)
    {
        snap_to_floor(ent, y_center);
    }
    return ent;
}

Entity* Layer::spawn_entity_over(ENT_TYPE id, Entity* overlay, float x, float y)
{
    using SpawnEntityFun = Entity*(EntityFactory*, ENT_TYPE, float, float, bool, Entity*, bool);
    static auto spawn_entity_raw = (SpawnEntityFun*)get_address("spawn_entity");
    using AddToLayer = void(Layer*, Entity*);
    static auto add_to_layer = (AddToLayer*)get_address("add_to_layer");
    using AddItemPtr = void(Entity*, Entity*, bool);
    static auto add_item_ptr = (AddItemPtr*)get_address("add_item_ptr");

    Entity* ent = spawn_entity_raw(entity_factory(), id, x, y, is_back_layer, overlay, true);

    const auto param_5 = true;
    if (((bool*)this)[0x64490] == false && param_5 == false)
    {
        add_item_ptr(((Entity**)this)[0x64440 / 0x8], ent, false);
    }
    else
    {
        add_to_layer(this, ent);
    }
    return ent;
}

Entity* Layer::get_grid_entity_at(float x, float y)
{
    const uint32_t ix = static_cast<uint32_t>(std::round(x));
    const uint32_t iy = static_cast<uint32_t>(std::round(y));
    if (ix < g_level_max_x && iy < g_level_max_y)
    {
        return grid_entities[iy][ix];
    }
    return nullptr;
}

Entity* Layer::get_entity_at(float x, float y, uint32_t search_flags, uint32_t include_flags, uint32_t exclude_flags, uint32_t one_of_flags)
{
    using get_entity_at_impl_fun = Entity*(Layer*, float, float, size_t, size_t, size_t, size_t);
    static auto get_entity_at_impl = (get_entity_at_impl_fun*)get_address("layer_get_entity_at"sv);
    return get_entity_at_impl(this, x, y, search_flags, include_flags, exclude_flags, one_of_flags);
}

Entity* Layer::spawn_door(float x, float y, uint8_t w, uint8_t l, uint8_t t)
{
    auto screen = State::ptr()->screen_next;
    Entity* door;
    switch (screen)
    {
    case 11:
    {
        door = spawn_entity(to_id("ENT_TYPE_FLOOR_DOOR_STARTING_EXIT"), round(x), round(y), false, 0.0, 0.0, true);
        break;
    }
    case 12:
    {
        door = spawn_entity(to_id("ENT_TYPE_FLOOR_DOOR_EXIT"), round(x), round(y), false, 0.0, 0.0, true);
        break;
    }
    default:
        return nullptr;
    };
    door->as<ExitDoor>()->world = w;
    door->as<ExitDoor>()->level = l;
    door->as<ExitDoor>()->theme = t;
    door->as<ExitDoor>()->special_door = true;
    spawn_entity(to_id("ENT_TYPE_LOGICAL_PLATFORM_SPAWNER"), round(x), round(y - 1.0f), false, 0.0, 0.0, true); // TODO: not needed if there is a floor below door
    return door;
}

Entity* Layer::spawn_apep(float x, float y, bool right)
{
    static const auto head_id = to_id("ENT_TYPE_MONS_APEP_HEAD");
    static const auto body_id = to_id("ENT_TYPE_MONS_APEP_BODY");
    constexpr auto facing_left_flag = 1 << 16;

    Entity* apep_head = spawn_entity(head_id, x, y, false, 0.0f, 0.0f, true);
    const bool facing_left = apep_head->flags & facing_left_flag;

    // Not pointing correct direction
    if (facing_left == right)
    {
        apep_head->flags = right
                               ? apep_head->flags & ~facing_left_flag
                               : apep_head->flags | facing_left_flag;

        int current_uid = apep_head->uid;
        do
        {
            auto body_parts = apep_head->items;
            int temp = current_uid;
            for (auto body_part : body_parts.entities())
            {
                body_part->flags = right
                                       ? body_part->flags & ~facing_left_flag
                                       : body_part->flags | facing_left_flag;
                body_part->x *= -1.0f;
                if (body_part->type->id == body_id)
                {
                    current_uid = body_part->uid;
                }
            }
            if (temp == current_uid)
            {
                break;
            }
        } while (true);
    }

    return apep_head;
}

void Layer::move_grid_entity(Entity* ent, float x, float y, Layer* dest_layer)
{
    move_grid_entity(ent, static_cast<uint32_t>(std::round(x)), static_cast<uint32_t>(std::round(y)), dest_layer);
}

void Layer::move_grid_entity(Entity* ent, uint32_t x, uint32_t y, Layer* dest_layer)
{
    if (ent)
    {
        const auto pos = ent->position();
        const uint32_t current_grid_x = static_cast<uint32_t>(std::round(pos.first));
        const uint32_t current_grid_y = static_cast<uint32_t>(std::round(pos.second));
        if (current_grid_x < g_level_max_x && current_grid_y < g_level_max_y)
        {
            if (grid_entities[current_grid_y][current_grid_x] == ent)
                grid_entities[current_grid_y][current_grid_x] = nullptr;
        }
        if (x < g_level_max_x && y < g_level_max_y)
        {
            dest_layer->grid_entities[y][x] = ent;
        }
        for (auto item_ent : ent->items.entities())
        {
            move_grid_entity(item_ent, x + item_ent->x, y + item_ent->y, dest_layer);
        }
    }
}

void Layer::destroy_grid_entity(Entity* ent)
{
    if (ent)
    {
        auto items = ent->items.entities();
        for (auto ptr = items.cend(); ptr != items.cbegin();)
        {
            ptr--;
            Entity* item_ent = *ptr;
            if (!item_ent->is_player()) // if not player
            {
                destroy_grid_entity(item_ent);
            }
        }

        const auto pos = ent->position();
        const uint32_t current_grid_x = static_cast<uint32_t>(std::round(pos.first));
        const uint32_t current_grid_y = static_cast<uint32_t>(std::round(pos.second));
        if (current_grid_x < g_level_max_x && current_grid_y < g_level_max_y)
        {
            if (grid_entities[current_grid_y][current_grid_x] == ent)
            {
                grid_entities[current_grid_y][current_grid_x] = nullptr;
                update_liquid_collision_at(pos.first, pos.second, false);
            }
        }

        ent->flags |= 1U << (29 - 1); // set DEAD flag to prevent certain stuff like gold nuggets drop or particles from entities such as spikes
        ent->destroy();
    }
}
